Job Artifacts
-------------
=>to understand this consider example of building an app 
=>this will produce executable needed for users.

Job ------- ex: building app
|
|
|
produces outputs


so we use the action upload-artifact to get this done. 
s
we declare a job suhc as 
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Upload artifacts
        uses: actions/upload-artifact@V3
        with:
          name: dist-files // this is just a label for the artifact
          path: |
            dist
            package.json

In the path we declare the files which are to be stored.

=>The output generated by a job ex: app binary, website files.
https://drive.google.com/file/d/1D2obo4X2rX1lgLcA_kUj7lo2UV6Vzhty/view?usp=drive_link

=>We can have jobs that produces testing scripts and being an owner of jobs we want to have a look at them.

say in the workflow

name: Deploy website
on:
  push:
    branches:
      - main
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Install dependencies
        run: npm ci
      - name: Lint code
        run: npm run lint
      - name: Test code
        run: npm run test
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Install dependencies
        run: npm ci
      - name: Build website
        run: npm run build
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: echo "Deploying..."

=> In the jobs there is also a build job where the commands such as npm run build are getting executed.
=> But once the workflow is finished then the runner machine is shutdown and these files are lost.
=>so being a user we want to store these files and also use them if possible.

=>To do this we use the action upload-artifacts action which is used to store files/data(called artifacts).
=>These artifacts are generated during the execution of workflows.

ex:
- name: Upload artifacts
  uses: actions/upload-artifact@v3
  with:
    name: dist-files
    path:
      dist

=>When I want to use the artifacts produces from the previous job we cas use the action upload-artifact@v3

code:
jobs:
 - name: upload_artifacts
   uses: actions/upload-artifact@v3
   with:
    name: dist-files
    path:
      dist
      dist-files

#Download the artifacts from previous step
  - name: download-artifacts
    uses: actions/download-artifact@v3
    with:
      name: dist-files
  
  Note: in the download artifacts we need to use the same name as in the upload artifacts inside the "with" of actions/download-artifact@v3 job.

https://drive.google.com/file/d/1quGfxe_OyIe7DaTA26jv-ggWgdcvRRKQ/view?usp=drive_link

refer 71,72 for understanding the job outputs.

we use the job outputs to save the values generated by a particular step.


Dependency Caching
------------------
=> In the workflows there are different jobs having steps which are often repeated like
*Get code
*Lint Code
*Install dependencies etc.
  
=>But instead of doing this we can cache the dependencies.
We can do something like install dependencies and cache to use them again.

- It is so common that github has provided an action to cache the dependencies.
cache@v3

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Get code
      uses: actions/cache@v3
      with:
        path: ~/.npm    -- Github caches the contents of directory specified in the path parameter.
        key : deps-node-modules-${{hashFiles('**/package-lock.json')}} -- this key is used to retrive the cache in future and recreating the cache on runner machine.


hashFiles() - this function produces a unique value based on the file path passed.
package-lock.json - this will collect all the files 

whenever the file changes the hash value changes 